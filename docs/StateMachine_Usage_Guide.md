# ä¹é‡é‹å‘½ - ç‹€æ…‹æ©Ÿç³»çµ±ä½¿ç”¨èªªæ˜æ›¸

## ğŸ“‹ ç›®éŒ„
- [æ¦‚è¿°](#æ¦‚è¿°)
- [ç³»çµ±æ¶æ§‹](#ç³»çµ±æ¶æ§‹) 
- [æ ¸å¿ƒçµ„ä»¶è©³è§£](#æ ¸å¿ƒçµ„ä»¶è©³è§£)
- [å®Œæ•´å®‰è£æŒ‡å—](#å®Œæ•´å®‰è£æŒ‡å—)
- [åŸºç¤ä½¿ç”¨æ–¹æ³•](#åŸºç¤ä½¿ç”¨æ–¹æ³•)
- [ç‹€æ…‹ç”Ÿå‘½é€±æœŸç®¡ç†](#ç‹€æ…‹ç”Ÿå‘½é€±æœŸç®¡ç†)
- [äº‹ä»¶ç³»çµ±æ·±åº¦æ•´åˆ](#äº‹ä»¶ç³»çµ±æ·±åº¦æ•´åˆ)
- [å ´æ™¯ç®¡ç†å®Œå…¨æŒ‡å—](#å ´æ™¯ç®¡ç†å®Œå…¨æŒ‡å—)
- [æˆ°é¬¥ç³»çµ±ç‹€æ…‹æ©Ÿ](#æˆ°é¬¥ç³»çµ±ç‹€æ…‹æ©Ÿ)
- [å¯¦æˆ°ç¯„ä¾‹é›†](#å¯¦æˆ°ç¯„ä¾‹é›†)
- [é€²éšåŠŸèƒ½èˆ‡æŠ€å·§](#é€²éšåŠŸèƒ½èˆ‡æŠ€å·§)
- [æ€§èƒ½å„ªåŒ–æŒ‡å—](#æ€§èƒ½å„ªåŒ–æŒ‡å—)
- [èª¿è©¦å·¥å…·è©³è§£](#èª¿è©¦å·¥å…·è©³è§£)
- [æœ€ä½³å¯¦è¸èˆ‡æ¨¡å¼](#æœ€ä½³å¯¦è¸èˆ‡æ¨¡å¼)
- [å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ](#å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ)
- [APIåƒè€ƒæ‰‹å†Š](#apiåƒè€ƒæ‰‹å†Š)
- [æ“´å±•é–‹ç™¼æŒ‡å—](#æ“´å±•é–‹ç™¼æŒ‡å—)

---

## æ¦‚è¿°

### ğŸ¯ è¨­è¨ˆç†å¿µ

ä¹é‡é‹å‘½çš„ç‹€æ…‹æ©Ÿç³»çµ±æ˜¯ä¸€å€‹ä¼æ¥­ç´šã€å¤šå±¤æ¬¡ã€äº‹ä»¶é©…å‹•çš„ç‹€æ…‹ç®¡ç†æ¡†æ¶ï¼Œå°ˆç‚ºè¤‡é›œçš„éŠæˆ²æµç¨‹å’Œå¤§å‹é …ç›®è¨­è¨ˆã€‚ç³»çµ±éµå¾ªä»¥ä¸‹æ ¸å¿ƒè¨­è¨ˆåŸå‰‡ï¼š

- **å–®ä¸€è·è²¬åŸå‰‡** - æ¯å€‹ç‹€æ…‹æ©Ÿåªè² è²¬ç‰¹å®šé ˜åŸŸçš„ç‹€æ…‹ç®¡ç†
- **é–‹æ”¾å°é–‰åŸå‰‡** - æ˜“æ–¼æ“´å±•æ–°ç‹€æ…‹ï¼Œç„¡éœ€ä¿®æ”¹ç¾æœ‰ä»£ç¢¼
- **ä¾è³´å€’ç½®åŸå‰‡** - é€šé EventBus å¯¦ç¾é¬†è€¦åˆé€šä¿¡
- **çµ„åˆå„ªæ–¼ç¹¼æ‰¿** - ä½¿ç”¨çµ„åˆæ¨¡å¼æ§‹å»ºè¤‡é›œç‹€æ…‹é‚è¼¯

### ğŸ—ï¸ ç³»çµ±æ¶æ§‹æ¦‚è¦½

ç³»çµ±åŒ…å«å…©å€‹æ ¸å¿ƒç‹€æ…‹æ©Ÿå’Œä¸€å€‹å¤–éƒ¨æ‹–æ”¾ç®¡ç†å™¨ï¼š

#### 1. éŠæˆ²å ´æ™¯ç‹€æ…‹æ©Ÿ (GameSceneStateMachine)
- **è·è²¬ç¯„åœ**: ç®¡ç†ä¸»é¸å–®ã€é—œå¡é¸æ“‡ã€æˆ°é¬¥å ´æ™¯ã€çµç®—ç•«é¢ç­‰é ‚ç´šå ´æ™¯åˆ‡æ›
- **ç‹€æ…‹ç‰¹é»**: é•·ç”Ÿå‘½é€±æœŸã€å ´æ™¯ç´šåˆ¥çš„ç‹€æ…‹ç®¡ç†
- **å…¸å‹æµç¨‹**: ä¸»é¸å–® â†’ é—œå¡é¸æ“‡ â†’ æˆ°é¬¥ â†’ çµç®— â†’ ä¸»é¸å–®

#### 2. æˆ°é¬¥ç‹€æ…‹æ©Ÿ (BattleStateMachine)  
- **è·è²¬ç¯„åœ**: ç®¡ç†æˆ°é¬¥å…§éƒ¨çš„å›åˆåˆ¶æµç¨‹ã€ç©å®¶æ“ä½œã€æ•µäººè¡Œå‹•
- **ç‹€æ…‹ç‰¹é»**: å‹•æ…‹å‰µå»º/éŠ·æ¯€ã€ç´°ç²’åº¦çš„æˆ°é¬¥é‚è¼¯
- **å…¸å‹æµç¨‹**: æº–å‚™ â†’ ç©å®¶å›åˆ â†’ è¨ˆç®—éšæ®µ â†’ æ•µäººå›åˆ â†’ å‹è² åˆ¤å®š

#### 3. æ‹–æ”¾ç³»çµ± (DragDropManager)
- **è¨­è¨ˆæ±ºç­–**: ä½¿ç”¨ç¾æœ‰çš„å°ˆé–€åŒ– DragDropManager è€Œéç‹€æ…‹æ©Ÿ
- **è·è²¬ç¯„åœ**: è™•ç†æ‰€æœ‰æ‹–æ”¾ç›¸é—œçš„ UI äº¤äº’å’Œå‹•ç•«
- **é›†æˆæ–¹å¼**: é€šé StateManager æä¾›çµ±ä¸€æ¥å£

### ğŸ’¡ æŠ€è¡“å„ªå‹¢

- **ğŸ”„ ç†±æ’æ‹”æ”¯æŒ** - ç‹€æ…‹æ©Ÿå¯ä»¥å‹•æ…‹å‰µå»ºå’ŒéŠ·æ¯€
- **ğŸ“Š å®Œæ•´ç›£æ§** - æä¾›å…¨é¢çš„ç‹€æ…‹è®ŠåŒ–è¿½è¹¤å’Œèª¿è©¦å·¥å…·
- **ğŸ­ äº‹ä»¶é©…å‹•** - åŸºæ–¼ EventBus çš„é¬†è€¦åˆæ¶æ§‹
- **âš¡ é«˜æ€§èƒ½** - å„ªåŒ–çš„ç‹€æ…‹è½‰æ›ç®—æ³•å’Œå…§å­˜ç®¡ç†
- **ğŸ›¡ï¸ é¡å‹å®‰å…¨** - å¼·é¡å‹çš„ç‹€æ…‹å®šç¾©å’Œè½‰æ›é©—è­‰
- **ğŸ“š è‡ªæ–‡æª”åŒ–** - è±å¯Œçš„èª¿è©¦ä¿¡æ¯å’Œç‹€æ…‹æ­·å²è¨˜éŒ„

## ç³»çµ±æ¶æ§‹

### æ¶æ§‹åœ–
```
StateManager (AutoLoad)
â”œâ”€â”€ GameSceneStateMachine (å ´æ™¯ç®¡ç†)
â”‚   â”œâ”€â”€ MainMenuState
â”‚   â”œâ”€â”€ LevelSelectionState
â”‚   â”œâ”€â”€ BattleState
â”‚   â”œâ”€â”€ ResultState
â”‚   â””â”€â”€ SettingsState
â””â”€â”€ BattleStateMachine (æˆ°é¬¥ç®¡ç†ï¼Œå‹•æ…‹å‰µå»º)
    â”œâ”€â”€ PreparingState
    â”œâ”€â”€ PlayerTurnState
    â”œâ”€â”€ CalculatingState
    â”œâ”€â”€ EnemyTurnState
    â”œâ”€â”€ VictoryState
    â””â”€â”€ DefeatState

DragDropManager (AutoLoad) - ç¨ç«‹è™•ç†æ‹–æ”¾é‚è¼¯
â”œâ”€â”€ æ‹–æ‹½ç‹€æ…‹ç®¡ç†
â”œâ”€â”€ æ‹–æ‹½é è¦½ç³»çµ±
â”œâ”€â”€ æŠ•æ”¾å€åŸŸæª¢æ¸¬
â””â”€â”€ å‹•ç•«æ•ˆæœè™•ç†
```

### äº‹ä»¶æµå‘
```
EventBus â†â†’ StateManager â†â†’ StateMachines â†â†’ Game Objects
            â†“                     â†‘
     DragDropManager â†â†’ DraggableTiles & DropZones
```

---

## æ ¸å¿ƒçµ„ä»¶è©³è§£

### 1. BaseState (åŸºç¤ç‹€æ…‹é¡)
æ‰€æœ‰å…·é«”ç‹€æ…‹çš„åŸºé¡ï¼Œæä¾›ç‹€æ…‹ç”Ÿå‘½é€±æœŸç®¡ç†ã€‚

```gdscript
class_name BaseState extends RefCounted

# ä¸»è¦æ–¹æ³•
func enter(previous_state: BaseState = null, data: Dictionary = {})  # é€²å…¥ç‹€æ…‹
func exit(next_state: BaseState = null)                             # é›¢é–‹ç‹€æ…‹
func update(delta: float)                                           # æ¯å¹€æ›´æ–°
func handle_input(event: InputEvent)                               # è™•ç†è¼¸å…¥
func can_transition_to(next_state_id: String) -> bool              # è½‰æ›æª¢æŸ¥
func on_event(event_name: String, event_data: Dictionary = {})     # äº‹ä»¶è™•ç†
```

### 2. BaseStateMachine (åŸºç¤ç‹€æ…‹æ©Ÿé¡)
ç‹€æ…‹æ©Ÿæ ¸å¿ƒé‚è¼¯ï¼Œç®¡ç†ç‹€æ…‹è½‰æ›å’Œç”Ÿå‘½é€±æœŸã€‚

```gdscript
class_name BaseStateMachine extends Node

# ä¸»è¦æ–¹æ³•
func add_state(state: BaseState) -> bool                           # æ·»åŠ ç‹€æ…‹
func transition_to(state_id: String, data: Dictionary = {}) -> bool # ç‹€æ…‹è½‰æ›
func get_current_state_id() -> String                              # ç²å–ç•¶å‰ç‹€æ…‹
func is_in_state(state_id: String) -> bool                        # æª¢æŸ¥ç‹€æ…‹
func go_back(data: Dictionary = {}) -> bool                        # è¿”å›ä¸Šä¸€ç‹€æ…‹

# ä¿¡è™Ÿ
signal state_changed(previous_state_id: String, current_state_id: String)
signal transition_failed(from_state_id: String, to_state_id: String, reason: String)
```

### 3. StateManager (ç‹€æ…‹æ©Ÿç®¡ç†å™¨ AutoLoad)
çµ±ä¸€ç®¡ç†æ‰€æœ‰ç‹€æ…‹æ©Ÿå¯¦ä¾‹ï¼Œæä¾›å…¨åŸŸæ§åˆ¶æ¥å£ã€‚

```gdscript
# ä¸»è¦å±¬æ€§
var game_scene_state_machine: GameSceneStateMachine
var battle_state_machine: BattleStateMachine  # å‹•æ…‹å‰µå»º

# ä¸»è¦æ–¹æ³•
func register_state_machine(name: String, state_machine: BaseStateMachine)
func get_state_machine(name: String) -> BaseStateMachine
func change_scene(scene_type, data: Dictionary = {})
func start_drag(object: Node, position: Vector2) -> bool  # å§”è¨—çµ¦DragDropManager
```

---

## å®Œæ•´å®‰è£æŒ‡å—

### ğŸ”§ ç³»çµ±è¦æ±‚

- **Godot ç‰ˆæœ¬**: 4.2+ (å»ºè­° 4.3+)
- **é …ç›®è¨­ç½®**: 2D æˆ– 3D é …ç›®å‡å¯
- **è…³æœ¬èªè¨€**: GDScript
- **æœ€å°å…§å­˜**: å»ºè­° 512MB+ å¯ç”¨å…§å­˜

### ğŸ“ æ–‡ä»¶çµæ§‹æº–å‚™

ç¢ºä¿ä½ çš„é …ç›®å…·æœ‰ä»¥ä¸‹ç›®éŒ„çµæ§‹ï¼š

```
é …ç›®æ ¹ç›®éŒ„/
â”œâ”€â”€ singletons/          # AutoLoad å–®ä¾‹ç›®éŒ„
â”‚   â”œâ”€â”€ EventBus.gd     # äº‹ä»¶ç¸½ç·šï¼ˆå¿…éœ€ï¼‰
â”‚   â”œâ”€â”€ StateManager.gd # ç‹€æ…‹ç®¡ç†å™¨ï¼ˆæœ¬ç³»çµ±æ ¸å¿ƒï¼‰
â”‚   â””â”€â”€ DragDropManager.gd  # æ‹–æ”¾ç®¡ç†å™¨ï¼ˆå¦‚æœéœ€è¦æ‹–æ”¾åŠŸèƒ½ï¼‰
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ state_machine/   # ç‹€æ…‹æ©Ÿè…³æœ¬ç›®éŒ„
â”‚       â”œâ”€â”€ BaseState.gd
â”‚       â”œâ”€â”€ BaseStateMachine.gd
â”‚       â”œâ”€â”€ GameSceneStateMachine.gd
â”‚       â””â”€â”€ BattleStateMachine.gd
â”œâ”€â”€ scenes/             # éŠæˆ²å ´æ™¯ç›®éŒ„ï¼ˆå¯é¸ï¼‰
â”‚   â”œâ”€â”€ MainMenu.tscn   # ä¸»é¸å–®å ´æ™¯
â”‚   â”œâ”€â”€ Battle.tscn     # æˆ°é¬¥å ´æ™¯
â”‚   â””â”€â”€ ...
â””â”€â”€ test_scenes/        # æ¸¬è©¦å ´æ™¯ç›®éŒ„ï¼ˆå¯é¸ï¼‰
    â””â”€â”€ StateMachineTest.gd
```

### ğŸ® AutoLoad é…ç½®è©³è§£

#### æ–¹æ³•1: é€šé Godot ç·¨è¼¯å™¨è¨­ç½®ï¼ˆæ¨è–¦ï¼‰

1. åœ¨ Godot ä¸­æ‰“é–‹ä½ çš„é …ç›®
2. é€²å…¥ `Project -> Project Settings`
3. åˆ‡æ›åˆ° `AutoLoad` é¸é …å¡
4. **æŒ‰ç…§ä»¥ä¸‹é †åº**æ·»åŠ  AutoLoad é …ç›®ï¼š

```
é †åº  åç¨±           è·¯å¾‘                               å–®ä¾‹
1     EventBus       res://singletons/EventBus.gd       âœ“
2     StateManager   res://singletons/StateManager.gd   âœ“
3     DragDropManager res://singletons/DragDropManager.gd âœ“ (å¦‚æœéœ€è¦)
```

âš ï¸ **é‡è¦**: AutoLoad çš„åŠ è¼‰é †åºå¾ˆé‡è¦ï¼EventBus å¿…é ˆåœ¨ StateManager ä¹‹å‰åŠ è¼‰ã€‚

#### æ–¹æ³•2: ç›´æ¥ç·¨è¼¯ project.godot æ–‡ä»¶

åœ¨ `project.godot` æ–‡ä»¶çš„ `[autoload]` éƒ¨åˆ†æ·»åŠ ï¼š

```ini
[autoload]

EventBus="*res://singletons/EventBus.gd"
StateManager="*res://singletons/StateManager.gd"
DragDropManager="*res://singletons/DragDropManager.gd"
```

### âœ… å®‰è£é©—è­‰

å‰µå»ºä¸€å€‹æ¸¬è©¦è…³æœ¬ä¾†é©—è­‰å®‰è£ï¼š

```gdscript
# TestStateManager.gd
extends Node

func _ready():
    await get_tree().process_frame  # ç­‰å¾… AutoLoad åˆå§‹åŒ–
    
    print("=== ç‹€æ…‹æ©Ÿç³»çµ±é©—è­‰ ===")
    
    # æª¢æŸ¥æ ¸å¿ƒçµ„ä»¶
    if StateManager == null:
        print("âŒ StateManager æœªè¼‰å…¥")
        return
        
    if EventBus == null:
        print("âŒ EventBus æœªè¼‰å…¥") 
        return
        
    print("âœ… æ ¸å¿ƒçµ„ä»¶è¼‰å…¥æˆåŠŸ")
    
    # æª¢æŸ¥ç‹€æ…‹æ©Ÿ
    var scene_sm = StateManager.get_state_machine("game_scene")
    if scene_sm == null:
        print("âŒ å ´æ™¯ç‹€æ…‹æ©Ÿæœªå‰µå»º")
        return
        
    print("âœ… å ´æ™¯ç‹€æ…‹æ©Ÿå‰µå»ºæˆåŠŸ")
    print("ç•¶å‰ç‹€æ…‹: ", scene_sm.get_current_state_id())
    
    # æ¸¬è©¦ç‹€æ…‹è½‰æ›
    var success = scene_sm.transition_to("level_selection")
    print("ç‹€æ…‹è½‰æ›çµæœ: ", "æˆåŠŸ" if success else "å¤±æ•—")
    
    print("=== é©—è­‰å®Œæˆ ===")
```

### ğŸ” å¸¸è¦‹å®‰è£å•é¡Œ

#### å•é¡Œ1: "StateManager not found" éŒ¯èª¤
**åŸå› **: AutoLoad æœªæ­£ç¢ºé…ç½®æˆ–è·¯å¾‘éŒ¯èª¤
**è§£æ±º**:
```gdscript
# æª¢æŸ¥ project.godot ä¸­æ˜¯å¦åŒ…å«:
[autoload]
StateManager="*res://singletons/StateManager.gd"

# ç¢ºèªæ–‡ä»¶è·¯å¾‘æ­£ç¢ºå­˜åœ¨
```

#### å•é¡Œ2: "Identifier 'GameSceneStateMachine' not declared"
**åŸå› **: è…³æœ¬æ–‡ä»¶ç¼ºå¤±æˆ– class_name æœªå®šç¾©
**è§£æ±º**:
```gdscript
# ç¢ºä¿æ¯å€‹ç‹€æ…‹æ©Ÿè…³æœ¬éƒ½æœ‰ class_name è²æ˜
class_name GameSceneStateMachine
extends BaseStateMachine
```

#### å•é¡Œ3: ç‹€æ…‹æ©Ÿåˆå§‹åŒ–å¤±æ•—
**åŸå› **: ä¾è³´çš„ AutoLoad æœªæ­£ç¢ºåŠ è¼‰
**è§£æ±º**:
```gdscript
func _ready():
    # åœ¨ä½¿ç”¨ç‹€æ…‹æ©Ÿå‰ç­‰å¾…ä¸€å¹€
    await get_tree().process_frame
    # ç¾åœ¨å¯ä»¥å®‰å…¨ä½¿ç”¨ StateManager
    StateManager.go_to_main_menu()
```

### ğŸš€ å¿«é€Ÿé–‹å§‹æ¨¡æ¿

å‰µå»ºä¸€å€‹æœ€å°åŒ–çš„ç¤ºä¾‹ä¾†æ¸¬è©¦ç³»çµ±ï¼š

```gdscript
# MinimalExample.gd
extends Node

func _ready():
    # ç­‰å¾…ç³»çµ±åˆå§‹åŒ–
    await get_tree().process_frame
    
    # ç›£è½ç‹€æ…‹è®ŠåŒ–
    EventBus.state_changed.connect(_on_state_changed)
    
    # æ¸¬è©¦å ´æ™¯åˆ‡æ›
    print("é–‹å§‹æ¸¬è©¦å ´æ™¯åˆ‡æ›...")
    StateManager.go_to_main_menu()
    
    await get_tree().create_timer(1.0).timeout
    
    # æ¸¬è©¦æˆ°é¬¥ç³»çµ±
    EventBus.battle_started.emit({
        "level_id": "test_level",
        "enemies": [{"id": "test_enemy", "hp": 100}]
    })

func _on_state_changed(sm_name: String, prev_state: String, current_state: String):
    print("[%s] %s -> %s" % [sm_name, prev_state, current_state])
```

---

## åŸºç¤ä½¿ç”¨æ–¹æ³•

1. **é…ç½® AutoLoad**
   åœ¨ `project.godot` ä¸­æ·»åŠ ï¼š
   ```
   [autoload]
   EventBus="*res://singletons/EventBus.gd"
   StateManager="*res://singletons/StateManager.gd"
   ```

2. **ç¢ºä¿è…³æœ¬ä½ç½®**
   ```
   scripts/state_machine/
   â”œâ”€â”€ BaseState.gd
   â”œâ”€â”€ BaseStateMachine.gd
   â”œâ”€â”€ GameSceneStateMachine.gd
   â”œâ”€â”€ BattleStateMachine.gd
   â””â”€â”€ DragDropStateMachine.gd
   ```

### åŸºæœ¬ä½¿ç”¨

#### å ´æ™¯åˆ‡æ›
```gdscript
# æ–¹æ³•1ï¼šä½¿ç”¨StateManagerä¾¿åˆ©æ–¹æ³•
StateManager.go_to_main_menu()
StateManager.go_to_battle("level_001")
StateManager.go_to_result("victory", [{"type": "gold", "amount": 100}])

# æ–¹æ³•2ï¼šä½¿ç”¨å ´æ™¯é¡å‹æšèˆ‰
StateManager.change_scene(GameSceneStateMachine.SceneType.MAIN_MENU)

# æ–¹æ³•3ï¼šé€šéEventBus
EventBus.scene_transition_requested.emit("level_selection", {"chapter": 1})
```

#### æ‹–æ”¾æ“ä½œï¼ˆä½¿ç”¨ç¾æœ‰DragDropManagerï¼‰
```gdscript
# é–‹å§‹æ‹–æ‹½
func _on_tile_input_event(viewport: Node, event: InputEvent, shape_idx: int):
    if event is InputEventMouseButton and event.pressed:
        # ç›´æ¥ä½¿ç”¨DragDropManager
        DragDropManager.start_drag(self, event.global_position)
        # æˆ–é€šéStateManagerå§”è¨—
        StateManager.start_drag(self, event.global_position)

# ç›£è½æ‹–æ”¾äº‹ä»¶ï¼ˆä½¿ç”¨DragDropManagerçš„ä¿¡è™Ÿï¼‰
func _ready():
    DragDropManager.tile_drag_started.connect(_on_drag_started)
    DragDropManager.tile_drag_ended.connect(_on_drag_ended)
    DragDropManager.navigation_requested.connect(_on_navigation_requested)

func _on_drag_ended(tile_data: Dictionary, drop_zone, success: bool):
    if success:
        print("æˆåŠŸæ”¾ç½®åœ–å¡Šåˆ° ", drop_zone.name if drop_zone else "æœªçŸ¥å€åŸŸ")
    else:
        print("æ‹–æ”¾å¤±æ•—")
```

#### æˆ°é¬¥æ§åˆ¶
```gdscript
# é–‹å§‹æˆ°é¬¥ï¼ˆè‡ªå‹•å‰µå»ºæˆ°é¬¥ç‹€æ…‹æ©Ÿï¼‰
EventBus.battle_started.emit({
    "level_id": "level_001",
    "enemies": [...],
    "player_hp": 100
})

# æäº¤ç©å®¶å›åˆ
StateManager.submit_player_turn()

# ç›£è½æˆ°é¬¥ç‹€æ…‹
func _ready():
    EventBus.turn_started.connect(_on_turn_started)
    EventBus.damage_calculated.connect(_on_damage_calculated)

func _on_turn_started(turn_number: int):
    print("ç¬¬ ", turn_number, " å›åˆé–‹å§‹")
```

---

## ç‹€æ…‹ç”Ÿå‘½é€±æœŸç®¡ç†

### ğŸ”„ ç‹€æ…‹ç”Ÿå‘½é€±æœŸæ¦‚è¿°

æ¯å€‹ç‹€æ…‹éƒ½æœ‰æ˜ç¢ºå®šç¾©çš„ç”Ÿå‘½é€±æœŸéšæ®µï¼Œç†è§£é€™äº›éšæ®µå°æ–¼æ­£ç¢ºä½¿ç”¨ç‹€æ…‹æ©Ÿè‡³é—œé‡è¦ï¼š

```mermaid
stateDiagram-v2
    [*] --> Created: new State()
    Created --> Entering: transition_to()
    Entering --> Active: enter() å®Œæˆ
    Active --> Active: update() / handle_input()
    Active --> Exiting: transition_to(other)
    Exiting --> [*]: exit() å®Œæˆ
    
    Active --> EventProcessing: on_event()
    EventProcessing --> Active: è™•ç†å®Œæˆ
```

### ğŸ“š ç”Ÿå‘½é€±æœŸæ–¹æ³•è©³è§£

#### 1. ç‹€æ…‹å‰µå»ºéšæ®µ

```gdscript
# ç‹€æ…‹å¯¦ä¾‹åŒ– - åªåŸ·è¡Œä¸€æ¬¡
class MyState extends BaseState:
    var some_data: Dictionary = {}
    
    func _init():
        super._init("my_state")
        # åˆå§‹åŒ–ä¸ä¾è³´å¤–éƒ¨æ•¸æ“šçš„å…§å®¹
        some_data["initialized_at"] = Time.get_unix_time_from_system()
        print("[MyState] ç‹€æ…‹å¯¦ä¾‹å·²å‰µå»º")
```

#### 2. é€²å…¥ç‹€æ…‹ (enter)

```gdscript
func enter(previous_state: BaseState = null, data: Dictionary = {}):
    super.enter(previous_state, data)
    
    # ç‹€æ…‹é€²å…¥æ™‚çš„åˆå§‹åŒ–å·¥ä½œ
    print("[MyState] é€²å…¥ç‹€æ…‹ï¼Œä¾†è‡ª: ", previous_state.state_id if previous_state else "ç„¡")
    
    # è™•ç†å‚³å…¥çš„æ•¸æ“š
    if data.has("player_level"):
        adjust_difficulty(data.player_level)
    
    # è¨­ç½®UIå…ƒç´ 
    setup_ui()
    
    # é–‹å§‹èƒŒæ™¯éŸ³æ¨‚
    AudioManager.play_bgm("state_music")
    
    # è¨»å†Šäº‹ä»¶ç›£è½
    EventBus.player_action.connect(_on_player_action)
    
    # å•Ÿå‹•ç‹€æ…‹ç‰¹å®šçš„è¨ˆæ™‚å™¨
    start_state_timer()

func setup_ui():
    # UI è¨­ç½®é‚è¼¯
    var ui_scene = preload("res://ui/MyStateUI.tscn").instantiate()
    get_tree().current_scene.add_child(ui_scene)
    
func start_state_timer():
    # ç‹€æ…‹ç‰¹å®šçš„è¨ˆæ™‚å™¨
    var timer = Timer.new()
    timer.wait_time = 5.0
    timer.one_shot = true
    timer.timeout.connect(_on_state_timeout)
    add_child(timer)
    timer.start()
```

#### 3. æ´»èºç‹€æ…‹ (update/handle_input/on_event)

```gdscript
# æ¯å¹€æ›´æ–° - è¬¹æ…ä½¿ç”¨ï¼Œé¿å…æ€§èƒ½å•é¡Œ
func update(delta: float):
    super.update(delta)
    
    # æ›´æ–°ç‹€æ…‹ç‰¹å®šçš„æ•¸æ“š
    update_animations(delta)
    check_win_conditions()
    
    # é¿å…åœ¨é€™è£¡åšé‡è¨ˆç®—
    # âŒ éŒ¯èª¤ç¤ºä¾‹ï¼šæ¯å¹€é‡æ–°è¨ˆç®—è·¯å¾‘
    # âœ… æ­£ç¢ºåšæ³•ï¼šåªåœ¨éœ€è¦æ™‚è¨ˆç®—

func handle_input(event: InputEvent):
    super.handle_input(event)
    
    # è™•ç†ç‹€æ…‹ç‰¹å®šçš„è¼¸å…¥
    if event is InputEventKey and event.pressed:
        match event.keycode:
            KEY_ESCAPE:
                # è«‹æ±‚é€€å‡ºç‹€æ…‹
                state_machine.transition_to("pause_menu")
            KEY_SPACE:
                # ç‹€æ…‹ç‰¹å®šæ“ä½œ
                perform_action()

func on_event(event_name: String, event_data: Dictionary = {}):
    super.on_event(event_name, event_data)
    
    # è™•ç†EventBusäº‹ä»¶
    match event_name:
        "player_died":
            handle_player_death(event_data)
        "item_collected":
            update_inventory(event_data)
        "enemy_spawned":
            register_enemy(event_data)
```

#### 4. é›¢é–‹ç‹€æ…‹ (exit)

```gdscript
func exit(next_state: BaseState = null):
    print("[MyState] é›¢é–‹ç‹€æ…‹ï¼Œå‰å¾€: ", next_state.state_id if next_state else "æœªçŸ¥")
    
    # æ¸…ç†å·¥ä½œ - éå¸¸é‡è¦ï¼
    cleanup_ui()
    cleanup_timers() 
    cleanup_event_listeners()
    save_state_data()
    
    # åœæ­¢èƒŒæ™¯éŸ³æ¨‚
    AudioManager.stop_bgm()
    
    # èª¿ç”¨çˆ¶é¡æ¸…ç†
    super.exit(next_state)

func cleanup_ui():
    # ç§»é™¤UIå…ƒç´ 
    var ui_nodes = get_tree().get_nodes_in_group("my_state_ui")
    for node in ui_nodes:
        node.queue_free()

func cleanup_event_listeners():
    # æ–·é–‹äº‹ä»¶é€£æ¥ - é˜²æ­¢å…§å­˜æ³„æ¼
    if EventBus.player_action.is_connected(_on_player_action):
        EventBus.player_action.disconnect(_on_player_action)

func cleanup_timers():
    # æ¸…ç†è¨ˆæ™‚å™¨
    for child in get_children():
        if child is Timer:
            child.queue_free()

func save_state_data():
    # ä¿å­˜ç‹€æ…‹æ•¸æ“šä¾›å¾ŒçºŒä½¿ç”¨
    GameData.set_state_data(state_id, {
        "last_exit_time": Time.get_unix_time_from_system(),
        "some_important_data": some_data
    })
```

### âš ï¸ ç”Ÿå‘½é€±æœŸæœ€ä½³å¯¦è¸

#### 1. è³‡æºç®¡ç†åŸå‰‡

```gdscript
# âœ… æ­£ç¢ºçš„è³‡æºç®¡ç†
class GameState extends BaseState:
    var ui_scene: Node = null
    var background_music: AudioStreamPlayer = null
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # å‰µå»ºè³‡æº
        ui_scene = preload("res://ui/GameUI.tscn").instantiate()
        get_tree().current_scene.add_child(ui_scene)
        
    func exit(next_state: BaseState = null):
        # æ¸…ç†è³‡æº
        if ui_scene:
            ui_scene.queue_free()
            ui_scene = null
            
        super.exit(next_state)

# âŒ éŒ¯èª¤çš„è³‡æºç®¡ç†
class BadState extends BaseState:
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        # æ²’æœ‰ä¿å­˜å¼•ç”¨ï¼Œç„¡æ³•æ­£ç¢ºæ¸…ç†
        preload("res://ui/GameUI.tscn").instantiate()
        get_tree().current_scene.add_child(ui_scene)  # ui_scene æœªå®šç¾©ï¼
```

#### 2. äº‹ä»¶ç›£è½ç®¡ç†

```gdscript
# âœ… æ­£ç¢ºçš„äº‹ä»¶ç›£è½ç®¡ç†
class ListeningState extends BaseState:
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        # é€£æ¥äº‹ä»¶
        EventBus.game_over.connect(_on_game_over)
        
    func exit(next_state: BaseState = null):
        # æ–·é–‹äº‹ä»¶ - é—œéµï¼
        if EventBus.game_over.is_connected(_on_game_over):
            EventBus.game_over.disconnect(_on_game_over)
        super.exit(next_state)
        
    func _on_game_over():
        # è™•ç†éŠæˆ²çµæŸ
        pass

# âŒ éŒ¯èª¤çš„äº‹ä»¶ç›£è½ç®¡ç† - æœƒå°è‡´å…§å­˜æ³„æ¼
class BadListeningState extends BaseState:
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        EventBus.game_over.connect(_on_game_over)
        # æ²’æœ‰åœ¨ exit ä¸­æ–·é–‹é€£æ¥ï¼
```

### ğŸ” ç‹€æ…‹è½‰æ›æ·±åº¦åˆ†æ

#### è½‰æ›æ™‚åºåœ–

```
ç‹€æ…‹A (ç•¶å‰)          ç‹€æ…‹æ©Ÿ              ç‹€æ…‹B (ç›®æ¨™)
    |                   |                    |
    |   transition_to   |                    |
    |------------------>|                    |
    |                   |   æª¢æŸ¥è½‰æ›æ¢ä»¶      |
    |                   |                    |
    |      exit()       |                    |
    |<------------------|                    |
    |   åŸ·è¡Œæ¸…ç†å·¥ä½œ     |                    |
    |                   |                    |
    |                   |      enter()      |
    |                   |------------------>|
    |                   |                   | åŸ·è¡Œåˆå§‹åŒ–å·¥ä½œ
    |                   |                   |
    |                   | state_changed äº‹ä»¶|
    |                   |------------------>| (EventBus)
```

#### æ¢ä»¶è½‰æ›ç¤ºä¾‹

```gdscript
class ConditionalState extends BaseState:
    func can_transition_to(next_state_id: String) -> bool:
        match next_state_id:
            "battle":
                # æª¢æŸ¥å¤šå€‹æ¢ä»¶
                return has_enough_energy() and \
                       has_valid_team() and \
                       level_is_unlocked()
            
            "shop":
                return has_currency()
                
            "settings":
                return true  # è¨­ç½®ç¸½æ˜¯å¯ä»¥é€²å…¥
                
            _:
                return super.can_transition_to(next_state_id)
    
    func has_enough_energy() -> bool:
        return GameData.player_energy >= 10
    
    func has_valid_team() -> bool:
        return GameData.current_team.size() > 0
    
    func level_is_unlocked() -> bool:
        return GameData.unlocked_levels.has(GameData.target_level)
```

---

## äº‹ä»¶ç³»çµ±æ·±åº¦æ•´åˆ

### ğŸ­ EventBus æ¶æ§‹è©³è§£

EventBus æ˜¯ç‹€æ…‹æ©Ÿç³»çµ±çš„ç¥ç¶“ä¸­æ¨ï¼Œè² è²¬å”èª¿æ‰€æœ‰çµ„ä»¶é–“çš„é€šä¿¡ï¼š

```gdscript
# EventBus äº‹ä»¶åˆ†é¡å’Œå‘½åè¦ç¯„
extends Node

# 1. ç³»çµ±ç´šäº‹ä»¶ï¼ˆå…¨å±€å½±éŸ¿ï¼‰
signal game_started()
signal game_paused(pause_data: Dictionary)
signal game_resumed()
signal application_focus_changed(focused: bool)

# 2. ç‹€æ…‹æ©Ÿäº‹ä»¶ï¼ˆç‹€æ…‹ç®¡ç†ï¼‰
signal state_changed(sm_name: String, previous: String, current: String)
signal transition_failed(sm_name: String, from: String, to: String, reason: String)
signal state_machine_created(sm_name: String, sm_instance: BaseStateMachine)

# 3. å ´æ™¯ç´šäº‹ä»¶ï¼ˆå ´æ™¯ç”Ÿå‘½é€±æœŸï¼‰
signal scene_transition_requested(target: String, data: Dictionary)
signal scene_entered(scene_name: String, load_time: float)
signal scene_exited(scene_name: String)
signal scene_load_progress(scene_name: String, progress: float)

# 4. æˆ°é¬¥ç³»çµ±äº‹ä»¶ï¼ˆæˆ°é¬¥é‚è¼¯ï¼‰
signal battle_started(level_data: Dictionary)
signal battle_ended(result: String, rewards: Array, statistics: Dictionary)
signal turn_started(turn_number: int, player_type: String)
signal turn_ended(turn_summary: Dictionary)
signal damage_calculated(damage_info: Dictionary)
signal skill_activated(skill_id: String, caster: Node, targets: Array)

# 5. ç©å®¶äº¤äº’äº‹ä»¶ï¼ˆç”¨æˆ¶æ“ä½œï¼‰
signal player_input_received(input_type: String, input_data: Dictionary)
signal ui_element_clicked(element_id: String, context: Dictionary)
signal drag_operation_completed(operation_result: Dictionary)

# 6. éŠæˆ²é‚è¼¯äº‹ä»¶ï¼ˆæ¥­å‹™é‚è¼¯ï¼‰
signal resource_changed(resource_type: String, old_value: int, new_value: int)
signal achievement_unlocked(achievement_id: String)
signal level_completed(level_id: String, score: int, time: float)
```

### ğŸ”— äº‹ä»¶è¨‚é–±èˆ‡ç™¼å¸ƒæ¨¡å¼

#### 1. ç‹€æ…‹æ©Ÿè‡ªå‹•äº‹ä»¶è¨‚é–±

```gdscript
class AutoEventState extends BaseState:
    # è‡ªå‹•äº‹ä»¶è¨‚é–±è¡¨
    var event_subscriptions: Dictionary = {
        "player_died": "_on_player_died",
        "item_collected": "_on_item_collected", 
        "enemy_defeated": "_on_enemy_defeated"
    }
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # è‡ªå‹•è¨‚é–±äº‹ä»¶
        for event_name in event_subscriptions:
            var method_name = event_subscriptions[event_name]
            if EventBus.has_signal(event_name) and has_method(method_name):
                EventBus.connect(event_name, Callable(self, method_name))
                print("[%s] è¨‚é–±äº‹ä»¶: %s -> %s" % [state_id, event_name, method_name])
    
    func exit(next_state: BaseState = null):
        # è‡ªå‹•å–æ¶ˆè¨‚é–±
        for event_name in event_subscriptions:
            var method_name = event_subscriptions[event_name]
            if EventBus.has_signal(event_name) and EventBus.is_connected(event_name, Callable(self, method_name)):
                EventBus.disconnect(event_name, Callable(self, method_name))
        
        super.exit(next_state)
    
    # äº‹ä»¶è™•ç†æ–¹æ³•
    func _on_player_died(death_data: Dictionary):
        print("[%s] ç©å®¶æ­»äº¡: %s" % [state_id, death_data])
        state_machine.transition_to("game_over", death_data)
    
    func _on_item_collected(item_data: Dictionary):
        print("[%s] æ”¶é›†ç‰©å“: %s" % [state_id, item_data.item_name])
        # æ›´æ–°UIæˆ–è§¸ç™¼å‹•ç•«
    
    func _on_enemy_defeated(enemy_data: Dictionary):
        print("[%s] æ•µäººè¢«æ“Šæ•—: %s" % [state_id, enemy_data.enemy_id])
        # æª¢æŸ¥å‹åˆ©æ¢ä»¶
```

#### 2. æ¢ä»¶äº‹ä»¶è™•ç†

```gdscript
class ConditionalEventState extends BaseState:
    var active_conditions: Dictionary = {}
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # è¨­ç½®æ¢ä»¶ç›£è½
        setup_conditional_events()
    
    func setup_conditional_events():
        # è¤‡é›œæ¢ä»¶ï¼šç•¶ç©å®¶è¡€é‡ä½æ–¼20%ä¸”æ•µäººæ•¸é‡>3æ™‚
        add_condition("low_health_many_enemies", {
            "events": ["player_health_changed", "enemy_count_changed"],
            "condition": func(): return GameData.player_health < GameData.max_health * 0.2 and GameData.enemy_count > 3,
            "action": func(): state_machine.transition_to("desperate_mode")
        })
        
        # æ™‚é–“æ¢ä»¶ï¼šæˆ°é¬¥è¶…é5åˆ†é˜
        add_condition("battle_timeout", {
            "events": ["turn_started"],
            "condition": func(): return Time.get_time_dict_from_system().get("unix") - battle_start_time > 300,
            "action": func(): EventBus.emit_signal("battle_timeout_warning")
        })
    
    func add_condition(condition_name: String, condition_data: Dictionary):
        active_conditions[condition_name] = condition_data
        
        # ç‚ºç›¸é—œäº‹ä»¶æ·»åŠ ç›£è½
        for event_name in condition_data.events:
            if not EventBus.is_connected(event_name, _on_conditional_event):
                EventBus.connect(event_name, _on_conditional_event)
    
    func _on_conditional_event(event_data: Dictionary = {}):
        # æª¢æŸ¥æ‰€æœ‰æ´»èºæ¢ä»¶
        for condition_name in active_conditions:
            var condition = active_conditions[condition_name]
            if condition.condition.call():
                print("[%s] æ¢ä»¶è§¸ç™¼: %s" % [state_id, condition_name])
                condition.action.call()
                # å¯é¸ï¼šè§¸ç™¼å¾Œç§»é™¤æ¢ä»¶
                # active_conditions.erase(condition_name)
```

#### 3. äº‹ä»¶éˆèˆ‡ç´šè¯è™•ç†

```gdscript
class EventChainState extends BaseState:
    var event_chain: Array = []
    var current_chain_step: int = 0
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # è¨­ç½®äº‹ä»¶éˆ
        setup_event_chain()
        start_event_chain()
    
    func setup_event_chain():
        # å®šç¾©è¤‡é›œçš„äº‹ä»¶åºåˆ—
        event_chain = [
            {
                "name": "intro_animation",
                "duration": 2.0,
                "action": func(): play_intro_animation(),
                "next_event": "show_dialogue"
            },
            {
                "name": "show_dialogue", 
                "trigger": "dialogue_finished",
                "action": func(): show_character_dialogue(),
                "next_event": "enable_player_input"
            },
            {
                "name": "enable_player_input",
                "action": func(): enable_player_controls(),
                "next_event": null  # éˆçµæŸ
            }
        ]
    
    func start_event_chain():
        if event_chain.size() > 0:
            execute_chain_step(0)
    
    func execute_chain_step(step_index: int):
        if step_index >= event_chain.size():
            print("[%s] äº‹ä»¶éˆå®Œæˆ" % state_id)
            return
            
        current_chain_step = step_index
        var step = event_chain[step_index]
        
        print("[%s] åŸ·è¡Œäº‹ä»¶éˆæ­¥é©Ÿ: %s" % [state_id, step.name])
        step.action.call()
        
        # è¨­ç½®ä¸‹ä¸€æ­¥è§¸ç™¼æ¢ä»¶
        if step.has("duration"):
            # æ™‚é–“è§¸ç™¼
            get_tree().create_timer(step.duration).timeout.connect(_on_chain_timer)
        elif step.has("trigger"):
            # äº‹ä»¶è§¸ç™¼
            EventBus.connect(step.trigger, _on_chain_event_triggered)
        else:
            # ç«‹å³åŸ·è¡Œä¸‹ä¸€æ­¥
            call_deferred("execute_next_step")
    
    func execute_next_step():
        var current_step = event_chain[current_chain_step]
        if current_step.next_event:
            var next_index = event_chain.find(func(step): return step.name == current_step.next_event)
            if next_index != -1:
                execute_chain_step(next_index)
        else:
            print("[%s] äº‹ä»¶éˆçµæŸ" % state_id)
    
    func _on_chain_timer():
        execute_next_step()
    
    func _on_chain_event_triggered():
        execute_next_step()
```

### ğŸ“¡ äº‹ä»¶å„ªå…ˆç´šèˆ‡éæ¿¾

```gdscript
class PriorityEventState extends BaseState:
    enum EventPriority {
        LOW = 0,
        NORMAL = 1, 
        HIGH = 2,
        CRITICAL = 3
    }
    
    var event_filters: Dictionary = {}
    var event_queue: Array = []
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # è¨­ç½®äº‹ä»¶éæ¿¾å™¨
        setup_event_filters()
        
        # é€£æ¥åˆ°æ‰€æœ‰ç›¸é—œäº‹ä»¶
        EventBus.connect("player_action", _on_event_received.bind("player_action", EventPriority.NORMAL))
        EventBus.connect("enemy_attack", _on_event_received.bind("enemy_attack", EventPriority.HIGH))
        EventBus.connect("system_error", _on_event_received.bind("system_error", EventPriority.CRITICAL))
    
    func setup_event_filters():
        # åªåœ¨ç‰¹å®šæ¢ä»¶ä¸‹è™•ç†æŸäº›äº‹ä»¶
        event_filters = {
            "player_action": func(data): return is_player_turn(),
            "enemy_attack": func(data): return not is_player_invulnerable(),
            "item_use": func(data): return has_item(data.item_id)
        }
    
    func _on_event_received(event_name: String, priority: EventPriority, event_data: Dictionary = {}):
        # æ‡‰ç”¨éæ¿¾å™¨
        if event_filters.has(event_name):
            if not event_filters[event_name].call(event_data):
                print("[%s] äº‹ä»¶è¢«éæ¿¾: %s" % [state_id, event_name])
                return
        
        # æ·»åŠ åˆ°å„ªå…ˆç´šéšŠåˆ—
        var event_item = {
            "name": event_name,
            "priority": priority,
            "data": event_data,
            "timestamp": Time.get_time_dict_from_system()
        }
        
        add_to_priority_queue(event_item)
        process_event_queue()
    
    func add_to_priority_queue(event_item: Dictionary):
        # æŒ‰å„ªå…ˆç´šæ’å…¥éšŠåˆ—
        var inserted = false
        for i in range(event_queue.size()):
            if event_queue[i].priority < event_item.priority:
                event_queue.insert(i, event_item)
                inserted = true
                break
        
        if not inserted:
            event_queue.append(event_item)
    
    func process_event_queue():
        while event_queue.size() > 0:
            var event_item = event_queue.pop_front()
            handle_prioritized_event(event_item)
    
    func handle_prioritized_event(event_item: Dictionary):
        print("[%s] è™•ç†å„ªå…ˆç´šäº‹ä»¶: %s (å„ªå…ˆç´š: %d)" % [state_id, event_item.name, event_item.priority])
        
        match event_item.name:
            "system_error":
                handle_critical_error(event_item.data)
            "enemy_attack":
                handle_enemy_attack(event_item.data)
            "player_action":
                handle_player_action(event_item.data)
```

### ğŸ¯ è‡ªå®šç¾©äº‹ä»¶ç³»çµ±æ“´å±•

```gdscript
# ç‚ºä½ çš„é …ç›®å‰µå»ºå°ˆé–€çš„äº‹ä»¶ç®¡ç†å™¨
class GameEventManager extends Node:
    
    # äº‹ä»¶çµ±è¨ˆ
    var event_statistics: Dictionary = {}
    
    # äº‹ä»¶å›æ”¾ç³»çµ±
    var event_history: Array = []
    var max_history_size: int = 1000
    
    # äº‹ä»¶é©—è­‰
    var event_validators: Dictionary = {}
    
    func _ready():
        # é€£æ¥åˆ° EventBus é€²è¡Œäº‹ä»¶æ””æˆªå’Œè™•ç†
        EventBus.connect("*", _on_any_event)  # éœ€è¦ä¿®æ”¹ EventBus æ”¯æŒé€šé…ç¬¦
    
    func emit_validated_event(event_name: String, event_data: Dictionary = {}):
        # é©—è­‰äº‹ä»¶æ•¸æ“š
        if not validate_event(event_name, event_data):
            push_error("äº‹ä»¶é©—è­‰å¤±æ•—: " + event_name)
            return false
        
        # è¨˜éŒ„çµ±è¨ˆ
        record_event_statistics(event_name)
        
        # æ·»åŠ åˆ°æ­·å²
        add_to_history(event_name, event_data)
        
        # ç™¼é€äº‹ä»¶
        EventBus.emit_signal(event_name, event_data)
        return true
    
    func validate_event(event_name: String, event_data: Dictionary) -> bool:
        if not event_validators.has(event_name):
            return true  # æ²’æœ‰é©—è­‰å™¨å°±é€šé
        
        return event_validators[event_name].call(event_data)
    
    func add_event_validator(event_name: String, validator: Callable):
        event_validators[event_name] = validator
    
    func record_event_statistics(event_name: String):
        if not event_statistics.has(event_name):
            event_statistics[event_name] = {"count": 0, "last_time": 0}
        
        event_statistics[event_name].count += 1
        event_statistics[event_name].last_time = Time.get_unix_time_from_system()
    
    func get_event_statistics() -> Dictionary:
        return event_statistics.duplicate()
    
    func replay_events_from_time(start_time: float):
        # äº‹ä»¶å›æ”¾åŠŸèƒ½ - ç”¨æ–¼èª¿è©¦å’Œæ¸¬è©¦
        for event in event_history:
            if event.timestamp >= start_time:
                EventBus.emit_signal(event.name, event.data)
                await get_tree().process_frame  # é€å¹€å›æ”¾
```

---

## å¯¦æˆ°ç¯„ä¾‹

### ç¯„ä¾‹1ï¼šè‡ªå®šç¾©å ´æ™¯ç‹€æ…‹

```gdscript
# å‰µå»ºå•†åº—å ´æ™¯ç‹€æ…‹
class ShopState extends BaseState:
    func _init():
        super._init("shop")
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        # è¼‰å…¥å•†åº—å ´æ™¯
        var shop_scene = load("res://scenes/Shop.tscn").instantiate()
        get_tree().root.add_child(shop_scene)
        
        # åˆå§‹åŒ–å•†åº—æ•¸æ“š
        if shop_scene.has_method("initialize_shop"):
            shop_scene.initialize_shop(data)
        
        EventBus.emit_signal("scene_entered", "shop")
    
    func can_transition_to(next_state_id: String) -> bool:
        # å•†åº—å¯ä»¥è¿”å›ä¸»é¸å–®æˆ–é€²å…¥å…¶ä»–å ´æ™¯
        return next_state_id in ["main_menu", "battle", "level_selection"]

# æ·»åŠ åˆ°å ´æ™¯ç‹€æ…‹æ©Ÿ
func _ready():
    var scene_sm = StateManager.get_state_machine("game_scene")
    scene_sm.add_state(ShopState.new())
```

### ç¯„ä¾‹2ï¼šè‡ªå®šç¾©æˆ°é¬¥ç‹€æ…‹

```gdscript
# å‰µå»ºæŠ€èƒ½é¸æ“‡ç‹€æ…‹
class SkillSelectionState extends BaseState:
    var available_skills: Array = []
    var selected_skill: String = ""
    
    func _init():
        super._init("skill_selection")
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        available_skills = data.get("skills", [])
        
        # é¡¯ç¤ºæŠ€èƒ½é¸æ“‡UI
        EventBus.emit_signal("ui_popup_requested", "skill_selection", {
            "skills": available_skills
        })
    
    func on_event(event_name: String, event_data: Dictionary = {}):
        super.on_event(event_name, event_data)
        
        match event_name:
            "skill_selected":
                selected_skill = event_data.get("skill_id", "")
                _confirm_skill_selection()
    
    func _confirm_skill_selection():
        # åŸ·è¡ŒæŠ€èƒ½ä¸¦è¿”å›æˆ°é¬¥ç‹€æ…‹
        EventBus.emit_signal("skill_activated", selected_skill)
        state_machine.transition_to("calculating", {"skill_used": selected_skill})
```

### ç¯„ä¾‹3ï¼šé«˜ç´šæ‹–æ”¾é‚è¼¯

```gdscript
# æ“´å±•æ‹–æ”¾ç‹€æ…‹æ©Ÿæ”¯æŒå¤šé¸
class MultiSelectDragState extends BaseState:
    var selected_objects: Array = []
    
    func _init():
        super._init("multi_dragging")
    
    func enter(previous_state: BaseState = null, data: Dictionary = {}):
        super.enter(previous_state, data)
        
        selected_objects = data.get("objects", [])
        
        # å‰µå»ºå¤šç‰©ä»¶é è¦½
        _create_multi_preview()
    
    func handle_input(event: InputEvent):
        super.handle_input(event)
        
        if event is InputEventMouseMotion:
            _update_multi_preview_positions(event.global_position)
    
    func _create_multi_preview():
        # ç‚ºæ¯å€‹é¸ä¸­ç‰©ä»¶å‰µå»ºé è¦½
        for obj in selected_objects:
            # å¯¦ç¾å¤šç‰©ä»¶é è¦½é‚è¼¯
            pass
```

---

## é€²éšåŠŸèƒ½

### ç‹€æ…‹æ­·å²è¿½è¹¤

```gdscript
# ç²å–ç‹€æ…‹æ­·å²
var scene_sm = StateManager.get_state_machine("game_scene")
var debug_info = scene_sm.get_debug_info()
print("ç‹€æ…‹æ­·å²: ", debug_info.state_history)

# è¿”å›ä¸Šä¸€ç‹€æ…‹
scene_sm.go_back()
```

### æ¢ä»¶ç‹€æ…‹è½‰æ›

```gdscript
class ConditionalState extends BaseState:
    func can_transition_to(next_state_id: String) -> bool:
        match next_state_id:
            "battle":
                # æª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ é«”åŠ›
                return GameData.player_energy > 0
            "shop":
                # æª¢æŸ¥æ˜¯å¦è§£é–å•†åº—
                return GameData.shop_unlocked
            _:
                return true
```

### ç‹€æ…‹æ•¸æ“šæŒä¹…åŒ–

```gdscript
# ä¿å­˜ç‹€æ…‹æ•¸æ“š
func save_state_data():
    var state_data = {
        "current_scene": StateManager.get_current_scene_state(),
        "scene_history": StateManager.game_scene_state_machine.state_history,
        "battle_state": StateManager.get_current_battle_state()
    }
    
    # ä¿å­˜åˆ°æ–‡ä»¶æˆ–ç©å®¶æ•¸æ“š
    GameData.save_state_machine_data(state_data)

# æ¢å¾©ç‹€æ…‹æ•¸æ“š
func restore_state_data():
    var state_data = GameData.load_state_machine_data()
    
    if state_data.has("current_scene"):
        StateManager.game_scene_state_machine.transition_to(state_data.current_scene)
```

---

## èª¿è©¦å·¥å…·

### ç‹€æ…‹æ©Ÿèª¿è©¦é¢æ¿

```gdscript
# é¡¯ç¤ºèª¿è©¦ä¿¡æ¯
StateManager.print_debug_info()

# ç²å–è©³ç´°èª¿è©¦æ•¸æ“š
var debug_data = StateManager.get_debug_info()
for sm_name in debug_data.state_machines:
    var sm_info = debug_data.state_machines[sm_name]
    print(sm_name, ": ", sm_info.current_state)
```

### å¯¦æ™‚ç‹€æ…‹ç›£æ§

```gdscript
# ç›£è½æ‰€æœ‰ç‹€æ…‹è®ŠåŒ–
func _ready():
    EventBus.state_changed.connect(_on_any_state_changed)

func _on_any_state_changed(sm_name: String, prev_state: String, current_state: String):
    print("[", sm_name, "] ", prev_state, " -> ", current_state)
```

### éŒ¯èª¤è¨ºæ–·

```gdscript
# ç›£è½è½‰æ›å¤±æ•—
func _ready():
    EventBus.transition_failed.connect(_on_transition_failed)

func _on_transition_failed(sm_name: String, from_state: String, to_state: String, reason: String):
    push_error("ç‹€æ…‹è½‰æ›å¤±æ•—: [" + sm_name + "] " + from_state + " -> " + to_state + " (" + reason + ")")
```

---

## æœ€ä½³å¯¦è¸

### 1. ç‹€æ…‹è¨­è¨ˆåŸå‰‡
- **å–®ä¸€è·è²¬**: æ¯å€‹ç‹€æ…‹åªè² è²¬ä¸€å€‹æ˜ç¢ºçš„éŠæˆ²ç‹€æ…‹
- **æœ€å°åŒ–æ•¸æ“š**: ç‹€æ…‹é–“åªå‚³éå¿…è¦çš„æ•¸æ“š
- **é¿å…å¾ªç’°ä¾è³´**: ç‹€æ…‹ä¸æ‡‰ç›´æ¥å¼•ç”¨å…¶ä»–ç‹€æ…‹

### 2. äº‹ä»¶é©…å‹•è¨­è¨ˆ
```gdscript
# âœ… å¥½çš„åšæ³•ï¼šä½¿ç”¨äº‹ä»¶é€šä¿¡
func on_enemy_defeated():
    EventBus.emit_signal("enemy_defeated", enemy_id, rewards)

# âŒ é¿å…ï¼šç›´æ¥èª¿ç”¨ç‹€æ…‹æ©Ÿæ–¹æ³•
func on_enemy_defeated():
    battle_state_machine.transition_to("victory")  # ç·Šè€¦åˆ
```

### 3. éŒ¯èª¤è™•ç†
```gdscript
# ç¸½æ˜¯æª¢æŸ¥ç‹€æ…‹è½‰æ›çµæœ
var success = state_machine.transition_to("next_state")
if not success:
    print("ç‹€æ…‹è½‰æ›å¤±æ•—ï¼ŒåŸ·è¡Œå‚™ç”¨é‚è¼¯")
    # åŸ·è¡Œå‚™ç”¨é‚è¼¯
```

### 4. æ€§èƒ½å„ªåŒ–
```gdscript
# é¿å…åœ¨updateä¸­åŸ·è¡Œè¤‡é›œé‚è¼¯
func update(delta: float):
    # âœ… è¼•é‡ç´šæ“ä½œ
    time_remaining -= delta
    
    # âŒ é¿å…é‡è¤‡çš„è¤‡é›œè¨ˆç®—
    # calculate_complex_ai_behavior()  
```

---

## å¸¸è¦‹å•é¡Œ

### Q: å¦‚ä½•æ·»åŠ æ–°çš„éŠæˆ²å ´æ™¯ï¼Ÿ
A: 
1. åœ¨ `GameSceneStateMachine.SceneType` æšèˆ‰ä¸­æ·»åŠ æ–°é¡å‹
2. æ›´æ–° `scene_paths` å’Œ `scene_state_mapping` å­—å…¸
3. å‰µå»ºå°æ‡‰çš„ç‹€æ…‹é¡
4. åœ¨ `_initialize_scene_states()` ä¸­æ·»åŠ ç‹€æ…‹

### Q: æˆ°é¬¥ç‹€æ…‹æ©Ÿä½•æ™‚å‰µå»ºå’ŒéŠ·æ¯€ï¼Ÿ
A: æˆ°é¬¥ç‹€æ…‹æ©Ÿåœ¨æ”¶åˆ° `battle_started` äº‹ä»¶æ™‚è‡ªå‹•å‰µå»ºï¼Œåœ¨ `battle_ended` äº‹ä»¶æ™‚è‡ªå‹•éŠ·æ¯€ã€‚é€™ç¢ºä¿äº†è¨˜æ†¶é«”çš„æœ‰æ•ˆåˆ©ç”¨ã€‚

### Q: å¦‚ä½•æ“´å±•æ‹–æ”¾åŠŸèƒ½æ”¯æŒæ–°çš„æ“ä½œï¼Ÿ
A: 
1. åœ¨ `DragDropStateMachine` ä¸­æ·»åŠ æ–°çš„ç‹€æ…‹é¡
2. æ“´å±• `DragDropStateType` æšèˆ‰
3. å¯¦ç¾å…·é«”çš„æ‹–æ”¾é‚è¼¯
4. é€šéEventBusç™¼é€ç›¸é—œäº‹ä»¶

### Q: ç‹€æ…‹æ©Ÿä¹‹é–“å¦‚ä½•é€šä¿¡ï¼Ÿ
A: ç‹€æ…‹æ©Ÿä¹‹é–“ä¸æ‡‰ç›´æ¥é€šä¿¡ï¼Œè€Œæ˜¯é€šéEventBusç™¼é€äº‹ä»¶ã€‚StateManageræœƒå”èª¿ä¸åŒç‹€æ…‹æ©Ÿçš„è¡Œç‚ºã€‚

### Q: å¦‚ä½•èª¿è©¦ç‹€æ…‹è½‰æ›å•é¡Œï¼Ÿ
A: 
1. å•Ÿç”¨èª¿è©¦æ¨¡å¼ï¼š`StateManager.set_debug_enabled(true)`
2. ç›£è½ `transition_failed` äº‹ä»¶
3. ä½¿ç”¨ `print_debug_info()` æŸ¥çœ‹ç‹€æ…‹æ©Ÿç‹€æ…‹
4. æª¢æŸ¥ `can_transition_to()` æ–¹æ³•çš„é‚è¼¯

---

## ç¸½çµ

ä¹é‡é‹å‘½çš„ç‹€æ…‹æ©Ÿç³»çµ±æä¾›äº†ï¼š
- ğŸ¯ **æ¸…æ™°çš„æ¶æ§‹** - åˆ†å±¤è¨­è¨ˆï¼Œè·è²¬æ˜ç¢º
- ğŸ”„ **éˆæ´»çš„æ“´å±•** - æ˜“æ–¼æ·»åŠ æ–°ç‹€æ…‹å’ŒåŠŸèƒ½  
- ğŸ­ **äº‹ä»¶é©…å‹•** - é¬†è€¦åˆçš„çµ„ä»¶é€šä¿¡
- ğŸ› ï¸ **è±å¯Œçš„å·¥å…·** - å®Œæ•´çš„èª¿è©¦å’Œç›£æ§åŠŸèƒ½
- ğŸ“š **å®Œå–„çš„æ–‡æª”** - è©³ç´°çš„ä½¿ç”¨æŒ‡å—å’Œç¯„ä¾‹

é€šéåˆç†ä½¿ç”¨é€™å€‹ç‹€æ…‹æ©Ÿç³»çµ±ï¼Œä½ å¯ä»¥è¼•é¬†ç®¡ç†è¤‡é›œçš„éŠæˆ²æµç¨‹ï¼Œè®“ä»£ç¢¼æ›´åŠ æ¸…æ™°ã€å¯ç¶­è­·å’Œå¯æ“´å±•ã€‚